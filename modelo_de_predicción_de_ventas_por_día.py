# -*- coding: utf-8 -*-
"""Modelo de Predicci√≥n de Ventas por D√≠a

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yku_xWDkAyCFDgYFi83G2C0PyRvpCue_
"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import gradio as gr
import uuid

# Dataset base
dias = np.array(list(range(1, 21))).reshape(-1, 1)
ventas = np.array([10, 12, 13, 15, 18, 17, 20, 22, 23, 25, 26, 28, 30, 32, 33, 35, 37, 38, 40, 42])

# Funci√≥n principal
def predecir_ventas(dia):
    if dia < 1:
        return "‚ùå El d√≠a debe ser mayor o igual que 1.", None, None

 # Autor: Laura Bl√°zquez

import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error
from sklearn.model_selection import train_test_split
import gradio as gr
import uuid

# Dataset base
dias = np.array(list(range(1, 21))).reshape(-1, 1)
ventas = np.array([10, 12, 13, 15, 18, 17, 20, 22, 23, 25, 26, 28, 30, 32, 33, 35, 37, 38, 40, 42])

# Funci√≥n principal
def predecir_ventas(dia):
    if dia < 1:
        return "‚ùå El d√≠a debe ser mayor o igual que 1.", None, None

    # Dividir datos aleatoriamente (sin random_state)
    dias_train, dias_test, ventas_train, ventas_test = train_test_split(dias, ventas, test_size=0.2)

    # Escalado
    scaler_dias = StandardScaler()
    scaler_ventas = StandardScaler()

    dias_train_escalado = scaler_dias.fit_transform(dias_train)
    ventas_train_escalado = scaler_ventas.fit_transform(ventas_train.reshape(-1, 1))
    dias_test_escalado = scaler_dias.transform(dias_test)
    ventas_test_escalado = scaler_ventas.transform(ventas_test.reshape(-1, 1))

    # Modelo
    modelo = LinearRegression()
    modelo.fit(dias_train_escalado, ventas_train_escalado)

    # Predicci√≥n
    dia_array = np.array([[dia]])
    dia_escalado = scaler_dias.transform(dia_array)
    prediccion_escalada = modelo.predict(dia_escalado)
    prediccion = scaler_ventas.inverse_transform(prediccion_escalada)[0][0]

    # RMSE
    predicciones_test_escaladas = modelo.predict(dias_test_escalado)
    predicciones_test = scaler_ventas.inverse_transform(predicciones_test_escaladas)
    rmse = np.sqrt(mean_squared_error(ventas_test, predicciones_test))

    # Graficar
    nombre_grafico = f"pred_{uuid.uuid4().hex}.png"

    dias_completos = np.vstack((dias_train, dias_test))
    ventas_completas = np.hstack((ventas_train, ventas_test))
    dias_completos_ordenados = dias_completos[np.argsort(dias_completos.flatten())]
    pred_todos_escalados = modelo.predict(scaler_dias.transform(dias_completos_ordenados))
    pred_todos = scaler_ventas.inverse_transform(pred_todos_escalados)

    plt.figure(figsize=(6, 4))
    plt.scatter(dias_train, ventas_train, color='blue', label='Entrenamiento')
    plt.scatter(dias_test, ventas_test, color='orange', label='Test')
    plt.plot(dias_completos_ordenados, pred_todos, color='green', linestyle='--', label='L√≠nea de regresi√≥n')
    plt.scatter([dia], [prediccion], color='red', label=f'Predicci√≥n d√≠a {dia}')
    plt.title('Predicci√≥n de Ventas')
    plt.xlabel('D√≠a')
    plt.ylabel('Unidades vendidas')
    plt.legend()
    plt.grid(True)
    plt.savefig(nombre_grafico)
    plt.close()

    resultado = f"‚úÖ Modelo reentrenado\nüìâ RMSE: {rmse:.2f}\nüìà Predicci√≥n para el d√≠a {dia}: {prediccion:.2f} unidades"
    return resultado, nombre_grafico, None

# Interfaz Gradio
gr.Interface(
    fn=predecir_ventas,
    inputs=gr.Slider(minimum=1, maximum=30, step=1, label="D√≠a a predecir"),
    outputs=[gr.Textbox(), gr.Image(type="filepath"), gr.Image(type="filepath")],
    title="üîÆ Predicci√≥n de Ventas por D√≠a",
    description="El modelo se entrena de nuevo cada vez. El RMSE cambiar√° seg√∫n la divisi√≥n de los datos."
).launch()